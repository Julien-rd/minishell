#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MINISHELL_PATH="$SCRIPT_DIR/../minishell"

# Run a specific test if the file name was specified
if [[ $1 ]]; then
	test_lists=(
		$1
	)
else
	test_lists=(
		"builtins"
		"pipes"
		"redirects"
		"extras"
	)
fi

BOLD="\e[1m"
YELLOW="\033[0;33m"
GREY="\033[38;5;244m"
PURPLE="\033[0;35m"
BLUE="\033[0;36m"
RED="\e[0;31m"
END="\033[0m"

chmod 000 ./test_files/invalid_permission
mkdir -p ./outfiles
mkdir -p ./mini_outfiles
mkdir -p ./bash_outfiles

printf $RED
echo "🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥";
echo "                                                                                             ";
echo " ██    ██ █ ██    █ █ █████ █   █ █████ █     █       ██████ █████ █████ ██████ █████ █████  ";
echo " ███  ███ █ ███   █ █ █     █   █ █     █     █         ██   █     █       ██   █     █   ██ ";
echo " █ ████ █ █ █ ██  █ █ █████ █████ ████  █     █         ██   ████  █████   ██   ████  █████  ";
echo " █  ██  █ █ █  ██ █ █     █ █   █ █     █     █         ██   █         █   ██   █     █   ██ ";
echo " █      █ █ █   ███ █ █████ █   █ █████ █████ █████     ██   █████ █████   ██   █████ █   ██ ";
echo "                                                                                             ";
echo "🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥";
echo "                                                                                              ";

# Verify minishell exists and is executable
echo "DEBUG: SCRIPT_DIR=$SCRIPT_DIR" >&2
echo "DEBUG: MINISHELL_PATH=$MINISHELL_PATH" >&2

if [[ ! -f "$MINISHELL_PATH" ]]; then
    echo "ERROR: minishell not found at: $MINISHELL_PATH" >&2
    echo "Current directory: $(pwd)" >&2
    echo "Contents of parent directory:" >&2
    ls -la "$SCRIPT_DIR/.." >&2
    exit 1
fi

if [[ ! -x "$MINISHELL_PATH" ]]; then
    echo "ERROR: minishell exists but is not executable" >&2
    echo "Run: chmod +x $MINISHELL_PATH" >&2
    exit 1
fi

ls -l $MINISHELL_PATH >&2

# Check if minishell prints a prompt in non-interactive mode
PROMPT_TEST=$(echo -e "exit\n" | $MINISHELL_PATH 2>/dev/null | head -n 1)
if [[ -n "$PROMPT_TEST" ]] && [[ ! "$PROMPT_TEST" =~ ^[[:space:]]*$ ]]; then
    PROMPT=$(echo "$PROMPT_TEST" | sed "s/\x1B\[[0-9;]\{1,\}[A-Za-z]//g")
    echo "DEBUG: Detected prompt: '$PROMPT'" >&2
else
    PROMPT=""
    echo "DEBUG: No prompt in non-interactive mode (this is normal)" >&2
fi

# Helper commands:
REMOVE_COLORS="sed s/\x1B\[[0-9;]\{1,\}[A-Za-z]//g"
REMOVE_EXIT="grep -v ^exit$"

for testfile in ${test_lists[*]}; do

	printf $RED
	echo ———————————— $testfile

	while read teste; do
		((i++))

		rm -rf ./outfiles/*
		rm -rf ./mini_outfiles/*
		
		# Execute minishell
		if [[ -n "$PROMPT" ]]; then
			MINI_OUTPUT=$(echo -e "$teste" | $MINISHELL_PATH 2> /dev/null | $REMOVE_COLORS | grep -vF "$PROMPT" | $REMOVE_EXIT )
		else
			MINI_OUTPUT=$(echo -e "$teste" | $MINISHELL_PATH 2> /dev/null | $REMOVE_COLORS | $REMOVE_EXIT )
		fi
		
		MINI_OUTFILES=$(cp ./outfiles/* ./mini_outfiles 2>/dev/null)
		
		# Get minishell exit code
		if [[ -n "$PROMPT" ]]; then
		    echo -e "$teste" | $MINISHELL_PATH >/dev/null 2>&1
		    MINI_EXIT_CODE=$?
		else
		    echo -e "$teste" | $MINISHELL_PATH >/dev/null 2>&1
		    MINI_EXIT_CODE=$?
		fi
		MINI_ERROR_MSG=$(trap "" PIPE && echo "$teste" | $MINISHELL_PATH 2>&1 > /dev/null | grep -o '[^:]*$' )

		rm -rf ./outfiles/*
		rm -rf ./bash_outfiles/*
		BASH_OUTPUT=$(echo -e "$teste" | bash 2> /dev/null)
		BASH_EXIT_CODE=$(echo $?)
		BASH_OUTFILES=$(cp ./outfiles/* ./bash_outfiles 2>/dev/null)
		BASH_ERROR_MSG=$(trap "" PIPE && echo "$teste" | bash 2>&1 > /dev/null | grep -o '[^:]*$' | head -n1)

		OUTFILES_DIFF=$(diff --brief ./mini_outfiles ./bash_outfiles 2>/dev/null)

		printf $YELLOW
		printf "Test %3s: " $i
		if [[ "$MINI_OUTPUT" == "$BASH_OUTPUT" && "$MINI_EXIT_CODE" == "$BASH_EXIT_CODE" && -z "$OUTFILES_DIFF" ]]; then
			printf ✅
			((ok++))
			if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
				printf "⚠️ "
			fi
		else
			printf ❌
		fi
		printf "$GREY $teste \n$END"
		if [ "$OUTFILES_DIFF" ]; then
			echo "$OUTFILES_DIFF"
			echo mini outfiles:
			cat ./mini_outfiles/* 2>/dev/null
			echo bash outfiles:
			cat ./bash_outfiles/* 2>/dev/null
		fi
		if [ "$MINI_OUTPUT" != "$BASH_OUTPUT" ]; then
			echo mini output = \($MINI_OUTPUT\)
			echo bash output = \($BASH_OUTPUT\)
		fi
		if [ "$MINI_EXIT_CODE" != "$BASH_EXIT_CODE" ]; then
			echo mini exit code = $MINI_EXIT_CODE
			echo bash exit code = $BASH_EXIT_CODE
		fi
		if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
			echo mini error = \($MINI_ERROR_MSG\)
			echo bash error = \($BASH_ERROR_MSG\)
		fi
	done < $testfile
done

chmod 666 ./test_files/invalid_permission
rm -rf ./outfiles
rm -rf ./mini_outfiles
rm -rf ./bash_outfiles

printf $PURPLE
printf $BOLD
echo   $ok/$i
printf $END

if [[ "$ok" == "$i" ]]; then
	echo "🎊 🎊 🎊"
	echo "😎 😎 😎"
	echo "🎉 🎉 🎉"
	exit 0
else
	echo "😭 😭 😭"
	exit 1
fi
